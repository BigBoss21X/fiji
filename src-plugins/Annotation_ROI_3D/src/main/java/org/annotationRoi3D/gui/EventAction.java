package org.annotationRoi3D.gui;

import ij.IJ;
import ij.ImagePlus;
import ij.WindowManager;

import java.awt.Component;
import java.awt.Container;
import java.awt.Scrollbar;
import java.awt.event.AdjustmentListener;
import java.awt.event.MouseWheelListener;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;

import org.annotationRoi3D.io.ExportFileChooser;
import org.annotationRoi3D.io.ImportFileChooser;
import org.annotationRoi3D.methods.Image;
import org.annotationRoi3D.methods.RoiDisplay;

/**
 * This class provides a semantic output when a component defined action occurs, 
 * this high-level event is generated by a component such as a Button when the 
 * action occurs such as being clicked.  
 *
 * @author William Grimes
 * @version 1.0.0
 */
public class EventAction extends InterfaceGUI{

	/**
	 * This method runs the plug-in MetaImage_Reader to open .mhd files, All images are opened
	 * in 16-bit since some features require 16-bit images or the same bit depth.  
	 */
	protected static void buttonOpenActionPerformed(java.awt.event.ActionEvent evt) {
		IJ.runPlugIn("org.annotationRoi3D.io.MetaImage_Reader", "");
		IJ.run("16-bit");
	}

	/**
	 * This method performs a 3D segmentation of the current image and uses the addImage()
	 * method to display ROI in a JList.
	 */	
	protected static void buttonIdentifyROIActionPerformed(java.awt.event.ActionEvent evt) {
		if (WindowManager.getCurrentWindow() == null){
			IJ.showMessage("No Image", "No images are open");
		}
		else{
			if (org.annotationRoi3D.gui.InterfaceGUI.identified == true){
				IJ.showMessage("ROIs Identied", "ROIs already identified");
			}
			else{
				lblImage.setText("Image: " + WindowManager.getCurrentWindow().toString());
				ImagePlus beforeSegmentation = WindowManager.getCurrentImage();
				org.annotationRoi3D.methods.Segmentation.segmentation3D();
				beforeSegmentation.hide();
				Image.addImage();
				identified = true;
			}
		}
	}

	/**
	 * Upon the event of a list value change the current Roi is shown in the image, in addition
	 * the values displayed in the GUI are updated to the relevant GUI.
	 */	
	protected static void listValueChanged(javax.swing.event.ListSelectionEvent evt) {	
		if (obj != null){
			obj.setComment(RoiComment.getText());
			if (chckbxCheckBox.isSelected()==true){
				obj.setName("true");
			}	
			else{
				obj.setName("false");
			}	
		}
		RoiDisplay.showRoi(true, false);
		RoiInformation.setText(
				"<html><table align=\"center\" style = \"font-family: Dialog; font-size: 12; color: #333333\">" +					
						"<tr>"
						+ "<td><b>ROI: </b></td><td>"+roiLabel+"</td>"
						+ "</tr>"+
						"</table>"
						+ "<table align=\"center\" style = \"font-family: Dialog; font-size: 12; color: #333333\">" +
						"<tr>"
						+ "<td><b>Volume: </b></td><td>"+volume+"</td>"
						+ "</tr>"
						+"</table>"						
						+ "<table align=\"center\" style = \"font-family: Dialog; font-size: 12; color: #333333\">" +
						"<tr>"
						+ "<td><b>Zmin: </b></td><td>"+Integer.toString(currentZmin)+"</td><td><b>Zmax: </b></td><td>"+Integer.toString(currentZmax)+"</td>"
						+ "</tr>"+
						"</table></html>" 	
				);
		RoiComment.setEnabled(true);
		if (chckbxCheckBox.isEnabled() == false){
			chckbxCheckBox.setEnabled(true);  
		}
		RoiComment.setText(comment);
		if (obj.getName().equals("true")){
			chckbxCheckBox.setSelected(true);
		}	
		else{
			chckbxCheckBox.setSelected(false);
		}	
	}

	/**
	 * This method runs merge channels function to merge channels of different colours.
	 * It is useful to create a composite image combining images based on colour. This
	 * feature requires images of the same bit-depth.  
	 */	
	protected static void buttonMergeChannelsActionPerformed(java.awt.event.ActionEvent evt) {
		IJ.run("Merge Channels...");
		imp = Image.getImage();
		imp = WindowManager.getCurrentImage();
		RoiDisplay.showRoi(true, false);
	}

	/**
	 * This method allows channels to be displayed by colour. It is useful to remove an 
	 * overlayed channel. 
	 */	
	protected static void buttonViewChannelsActionPerformed(java.awt.event.ActionEvent evt) {
		if (WindowManager.getCurrentWindow() == null){
			IJ.showMessage("No Image", "No images are open");
		}
		else{
			IJ.run("Channels Tool...", "");
		}
	}

	/**
	 * This method displays the current stack in orthogonal view showing sagittal sections, 
	 * coronal (YZ projection image) window and transverse (XZ projection image) window.
	 */	
	protected static void buttonOrthogonalViewsActionPerformed(java.awt.event.ActionEvent evt) {
		IJ.run("Orthogonal Views", "");
	}

	/**
	 * This method creates a sequence of projections of a rotating volume on one plane.
	 */	
	protected static void buttonView3DActionPerformed(java.awt.event.ActionEvent evt) {
		IJ.run("Select None", "");
		IJ.run(WindowManager.getCurrentImage(), "3D Project...", "projection=[Brightest Point] axis=Y-Axis slice=1 initial=0 total=360 rotation=10 lower=1 upper=255 opacity=0 surface=100 interior=50");
	}

	/**
	 * This method adjusts the image based on the selection in the scroll bar.
	 */	
	public static void addScrollListener(ImagePlus img, AdjustmentListener al, MouseWheelListener ml) {
		for (Component c : img.getWindow().getComponents()) {
			if (c instanceof Scrollbar) {
				((Scrollbar) c).addAdjustmentListener(al);
			} else if (c instanceof Container) {
				for (Component c2 : ((Container) c).getComponents()) {
					if (c2 instanceof Scrollbar) {
						((Scrollbar) c2).addAdjustmentListener(al);
					}
				}
			}
		}
		img.getWindow().addMouseWheelListener(ml);
	}

	/**
	 * This method removes the scroll listener so the image is not adjusted by selection in scroll bar.
	 */	
	public static void removeScrollListener(ImagePlus img, AdjustmentListener al, MouseWheelListener ml) {
		for (Component c : img.getWindow().getComponents()) {
			if (c instanceof Scrollbar) {
				((Scrollbar) c).removeAdjustmentListener(al);
			} else if (c instanceof Container) {
				for (Component c2 : ((Container) c).getComponents()) {
					if (c2 instanceof Scrollbar) {
						((Scrollbar) c2).removeAdjustmentListener(al);
					}
				}
			}
		}
		img.getWindow().removeMouseWheelListener(ml);
	}

	protected static void buttonXmlImportActionPerformed(java.awt.event.ActionEvent evt) {
		if (org.annotationRoi3D.gui.InterfaceGUI.identified == false){
			IJ.showMessage("Identify ROIs", "Identify ROIs before importing data");
		}
		else{
			ImportFileChooser importWindow = new ImportFileChooser();
		}
	} 

	/**
	 * This method launches the method to save files in XML format.
	 */	
	protected static void buttonXmlExportActionPerformed(java.awt.event.ActionEvent evt) {
		if (obj != null){
			obj.setComment(RoiComment.getText());
			if (chckbxCheckBox.isSelected()==true){
				obj.setName("true");
			}	
			else{
				obj.setName("false");
			}	
		}
		ExportFileChooser exportWindow = new ExportFileChooser();
	} 
}
